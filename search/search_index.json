{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Modular Orchestrated Core Arquitectura modular orientada a plugins y orquestadores por cliente (tenant) , dise\u00f1ada para escalar aplicaciones multi-cliente sin duplicar c\u00f3digo ni sacrificar personalizaci\u00f3n. Contexto Actualmente se mantienen 30 aplicaciones distintas (6 apps \u00d7 5 clientes), cada una con sus propias variaciones, niveles de actualizaci\u00f3n y mantenimiento. Con la incorporaci\u00f3n de un nuevo cliente (que requerir\u00e1 todas las apps) y el desarrollo de una nueva aplicaci\u00f3n, el sistema escalar\u00e1 a 42 instancias diferentes . Problemas detectados L\u00f3gica duplicada entre m\u00faltiples bases de c\u00f3digo Mantenimiento fragmentado e ineficiente Integraci\u00f3n de nuevos clientes lenta y costosa Alta complejidad en pruebas, QA y despliegue Objetivo Centralizar el desarrollo sobre una \u00fanica base de c\u00f3digo reutilizable, mediante una arquitectura compuesta por: Un n\u00facleo funcional com\u00fan ( core ) Plugins generales reutilizables (l\u00f3gica compartida) Orchestrators por cliente (personalizaci\u00f3n aislada por tenant) Esto permite mantener la l\u00f3gica compartida y personalizar comportamientos sin ramificar el sistema. Componentes principales ```plaintext \ud83d\udcc1 src \u251c\u2500\u2500 \ud83d\udcc1 core \u251c\u2500\u2500 \ud83d\udcc1 plugins \u2502 \u2514\u2500\u2500 \ud83d\udcc1 shared \u251c\u2500\u2500 \ud83d\udcc1 tenants \u2502 \u251c\u2500\u2500 \ud83d\udcc1 ClienteA \u2502 \u2502 \u2514\u2500\u2500 \ud83d\udcc4 Orchestrator.cs \u2502 \u2514\u2500\u2500 \ud83d\udcc1 ClienteB \u2502 \u2514\u2500\u2500 \ud83d\udcc4 Orchestrator.cs ```` Plugins compartidos : funcionalidades generales como pagos, notificaciones, etc. Orchestrators por cliente : definen qu\u00e9 plugins usar y c\u00f3mo configurarlos seg\u00fan el tenant. Loader : selecciona el orchestrator correcto al iniciar, usando TENANT_ID . C\u00f3mo funciona Se define la variable de entorno TENANT_ID al desplegar. Al arrancar, el sistema carga el orchestrator correspondiente. El orchestrator configura plugins y comportamientos del microservicio. El core ejecuta usando esa configuraci\u00f3n, de forma transparente. Esto elimina condicionales en tiempo de ejecuci\u00f3n y permite una personalizaci\u00f3n s\u00f3lida sin duplicaci\u00f3n. Ventajas C\u00f3digo centralizado y mantenible Plugins reusables , desacoplados y testeables Personalizaci\u00f3n controlada por tenant Escalado f\u00e1cil a nuevos clientes Despliegues consistentes y predecibles Consideraciones Requiere un dise\u00f1o modular disciplinado Los contratos entre core y plugins deben estar bien definidos Es fundamental tener una estrategia clara de: Versionado por plugin Pruebas por orchestrator Ideal para equipos que: Mantienen m\u00faltiples aplicaciones similares por cliente Quieren reducir deuda t\u00e9cnica y mantenimiento cruzado Necesitan escalar a nuevos clientes sin ramificar Buscan una base s\u00f3lida para crecimiento horizontal M\u00e1s informaci\u00f3n Documentaci\u00f3n t\u00e9cnica detallada Gu\u00eda para crear un plugin compartido C\u00f3mo definir un orchestrator por cliente","title":"Modular Orchestrated Core"},{"location":"#modular-orchestrated-core","text":"Arquitectura modular orientada a plugins y orquestadores por cliente (tenant) , dise\u00f1ada para escalar aplicaciones multi-cliente sin duplicar c\u00f3digo ni sacrificar personalizaci\u00f3n.","title":"Modular Orchestrated Core"},{"location":"#contexto","text":"Actualmente se mantienen 30 aplicaciones distintas (6 apps \u00d7 5 clientes), cada una con sus propias variaciones, niveles de actualizaci\u00f3n y mantenimiento. Con la incorporaci\u00f3n de un nuevo cliente (que requerir\u00e1 todas las apps) y el desarrollo de una nueva aplicaci\u00f3n, el sistema escalar\u00e1 a 42 instancias diferentes .","title":"Contexto"},{"location":"#problemas-detectados","text":"L\u00f3gica duplicada entre m\u00faltiples bases de c\u00f3digo Mantenimiento fragmentado e ineficiente Integraci\u00f3n de nuevos clientes lenta y costosa Alta complejidad en pruebas, QA y despliegue","title":"Problemas detectados"},{"location":"#objetivo","text":"Centralizar el desarrollo sobre una \u00fanica base de c\u00f3digo reutilizable, mediante una arquitectura compuesta por: Un n\u00facleo funcional com\u00fan ( core ) Plugins generales reutilizables (l\u00f3gica compartida) Orchestrators por cliente (personalizaci\u00f3n aislada por tenant) Esto permite mantener la l\u00f3gica compartida y personalizar comportamientos sin ramificar el sistema.","title":"Objetivo"},{"location":"#componentes-principales","text":"```plaintext \ud83d\udcc1 src \u251c\u2500\u2500 \ud83d\udcc1 core \u251c\u2500\u2500 \ud83d\udcc1 plugins \u2502 \u2514\u2500\u2500 \ud83d\udcc1 shared \u251c\u2500\u2500 \ud83d\udcc1 tenants \u2502 \u251c\u2500\u2500 \ud83d\udcc1 ClienteA \u2502 \u2502 \u2514\u2500\u2500 \ud83d\udcc4 Orchestrator.cs \u2502 \u2514\u2500\u2500 \ud83d\udcc1 ClienteB \u2502 \u2514\u2500\u2500 \ud83d\udcc4 Orchestrator.cs ```` Plugins compartidos : funcionalidades generales como pagos, notificaciones, etc. Orchestrators por cliente : definen qu\u00e9 plugins usar y c\u00f3mo configurarlos seg\u00fan el tenant. Loader : selecciona el orchestrator correcto al iniciar, usando TENANT_ID .","title":"Componentes principales"},{"location":"#como-funciona","text":"Se define la variable de entorno TENANT_ID al desplegar. Al arrancar, el sistema carga el orchestrator correspondiente. El orchestrator configura plugins y comportamientos del microservicio. El core ejecuta usando esa configuraci\u00f3n, de forma transparente. Esto elimina condicionales en tiempo de ejecuci\u00f3n y permite una personalizaci\u00f3n s\u00f3lida sin duplicaci\u00f3n.","title":"C\u00f3mo funciona"},{"location":"#ventajas","text":"C\u00f3digo centralizado y mantenible Plugins reusables , desacoplados y testeables Personalizaci\u00f3n controlada por tenant Escalado f\u00e1cil a nuevos clientes Despliegues consistentes y predecibles","title":"Ventajas"},{"location":"#consideraciones","text":"Requiere un dise\u00f1o modular disciplinado Los contratos entre core y plugins deben estar bien definidos Es fundamental tener una estrategia clara de: Versionado por plugin Pruebas por orchestrator","title":"Consideraciones"},{"location":"#ideal-para-equipos-que","text":"Mantienen m\u00faltiples aplicaciones similares por cliente Quieren reducir deuda t\u00e9cnica y mantenimiento cruzado Necesitan escalar a nuevos clientes sin ramificar Buscan una base s\u00f3lida para crecimiento horizontal","title":"Ideal para equipos que:"},{"location":"#mas-informacion","text":"Documentaci\u00f3n t\u00e9cnica detallada Gu\u00eda para crear un plugin compartido C\u00f3mo definir un orchestrator por cliente","title":"M\u00e1s informaci\u00f3n"},{"location":"1.context/background/","text":"","title":"Background"},{"location":"2.method/tenants/","text":"","title":"Tenants"},{"location":"2.method/components/core/","text":"","title":"Core"},{"location":"2.method/components/orchestrators/","text":"","title":"Orchestrators"},{"location":"2.method/components/plugins/","text":"","title":"Plugins"},{"location":"3.implementation/buenas-practicas/","text":"","title":"Buenas practicas"},{"location":"3.implementation/casos-de-uso/","text":"","title":"Casos de uso"}]}